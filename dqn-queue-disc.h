/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2018 Minsu Kim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Authors: Minsu Kim <minsu1.kim@ryerson.ca>
 */


#ifndef DQN_QUEUE_DISC_H
#define DQN_QUEUE_DISC_H

#include "ns3/queue-disc.h"
#include "ns3/nstime.h"
#include "ns3/boolean.h"
#include "ns3/data-rate.h"
#include "ns3/timer.h"
#include "ns3/event-id.h"

#include "/home/tiny-dnn/tiny_dnn/tiny_dnn.h"
#include <vector>
#include <tuple>
#include <deque>
#include <algorithm>
#include <cmath>
#include <random>

using action_t = uint32_t;
using observation_t = tiny_dnn::vec_t;	//	vec_t = typedef of std::vector<double>
using experience_t = std::tuple<observation_t, action_t, double, observation_t, bool>;	// current state, action, reward, next state, done
using memory_t = std::deque<experience_t>;

namespace ns3 {

class TraceContainer;

/**
 * \ingroup traffic-control
 *
 * \brief Implements DQN Active Queue Management discipline
 */
class DqnQueueDisc : public QueueDisc
{
public:
  /**
   * \brief Get the type ID.
   * \return the object TypeId
   */
  static TypeId GetTypeId (void);

  /**
   * \brief DqnQueueDisc Constructor
   */
  DqnQueueDisc ();

  /**
   * \brief DqnQueueDisc Destructor
   */
  virtual ~DqnQueueDisc ();

protected:
  /**
   * \brief Dispose of the object
   */
  virtual void DoDispose (void);

private:
  virtual bool DoEnqueue (Ptr<QueueDiscItem> item);
  virtual Ptr<QueueDiscItem> DoDequeue (void);
  virtual bool CheckConfig (void);


  /**
   * \brief Initialize the queue parameters.
   */
  virtual void InitializeParams (void);

	/*
	 * \brief Construct multi-layer perceptrons (MLP)
	 */
	void ConstructApproximationFunction(void);

	/*
	 * \brief Get current state
	 */
	observation_t GetObservation(void);

	/*
	 * \brief Calculate real-time packet enqueue / dequeue rate
	 */
	void PacketProcessingRate(Ptr<QueueDiscItem>& item, bool& measurement, uint32_t& threshold, double& start, uint64_t& count, double& rate);

	/*
	 * \brief Select action if it will select drop / non-drop state using state
	 */
	void SelectAction(void);

	/*
	 * \brief If selected action is dropping, drop the packet from queue
	 */
	void DropByDQN(void);
	
	/*
	 * \brief Calculate rewards
	 */
	void CalculateRewards(void);
	
	/*
	 * \brief Update MLP using replay memory
	 */
	void UpdateModel(memory_t m);

	static constexpr const char* EXCEEDED_DROP = "Dropped by exceeded queue";	// reason to packet drop
	static constexpr const char* DQN_PROB_DROP = "Dropped by DQN prediction";	// reason to packet drop
	static const uint64_t COUNT_INVALID = std::numeric_limits<uint64_t>::max();	// invalid packet count value

	// ** Variables for enqueue rate
	double m_enqueueRate;	// Enqueue Rate
	double m_enqueueStart;	// Start time of calculating enqueue rate
  uint64_t m_enqueueCount;	// Count number of bytes in queue within threshold
  bool m_enqueueMeasurement;	// Measruement to calculate enqueue rate or not
  uint32_t m_enqueueThreshold;	// Threshold for calculating enqueue rate
	
	// ** Variables for dequeue rate
	double m_dequeueRate;
	double m_dequeueStart;
  uint64_t m_dequeueCount;
  bool m_dequeueMeasurement;
  uint32_t m_dequeueThreshold;

	Time m_currQueueDelay;	// Current queue delay
	Time m_oldQueueDelay;
	Time m_desiredQueueDelay;	// Desired queue delay

	tiny_dnn::network<tiny_dnn::sequential> m_mainEstimator;	// Q estimator (main)
	tiny_dnn::network<tiny_dnn::sequential> m_targetEstimator;	// Target estimator

	// ** Variables for reward function
	double m_rewardsWeight;	// Weight for trade-off between delay and drop-rate
	DataRate m_physicalDataRate;	// Physical DataRate of the device / cable
	uint32_t m_nIotGroup;	// Number of IoT group (1 group has 22 devices)
	double m_singleReward;	// Rewards generated by single action
	uint32_t m_enqueuedPacket;	// Number of enqueued packets in queue within update period
	uint32_t m_droppedPacket;	// Number of dropped packets in queue within update period
	double m_gamma;	// Discount factor for reward
	double m_rewardsSum;	// Sum of rewards

	observation_t m_currState;	//  Current state
	observation_t m_nextState;	// Next state

	action_t m_action;	// Selected action

	memory_t m_replayMemory;	// Replay memory to train the estimator

	bool m_done;	// True if simulation is done

	uint32_t m_batchSize;	// Mini-batch size to train
	uint32_t m_targetUpdatePeriod;	// Target estimator update period

	Time m_updatePeriod;	// Interval of each "select action" and gap between current and next state
	EventId m_eventId;	// Event id to schedule "select action" and "calculate reward"
	bool m_actionTrigger;	// Action trigger (don't update or select action if queue delay is 0)
	
	uint32_t m_episode;	// Record #th episode for explore / exploit
	uint32_t m_episodeStepCount;	// Count step for actions
	
	bool m_trainingMode;	// True if it is training mode / False (test mode)
	
	uint32_t m_dropCount;	// Count the number of drop/non-drop state
	uint32_t m_nonDropCount;
	uint32_t m_randomCount;

	bool m_statusTrigger;	// show status in std output
	uint32_t m_rtt;	// round trip time for link between edge and cloud gateway
};

};   // namespace ns3

#endif

